---
phase: 03-stash-creator
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified: [src/app.rs]
autonomous: true

must_haves:
  truths:
    - "User presses 's' to initiate stash creation and sees a text input popup for the stash message"
    - "User can type a stash message with full text editing (characters, backspace, cursor movement)"
    - "User presses Enter to confirm and the stash is created from selected files with the entered message"
    - "User presses Escape to cancel the message input without creating a stash"
    - "After successful stash creation, the file list refreshes to show the updated working directory state"
    - "If no files are selected when 's' is pressed, user sees an error message instead of the popup"
  artifacts:
    - path: "src/app.rs"
      provides: "MessageInputState, stash creation with pathspecs, text input popup rendering"
      contains: "MessageInputState|stash_save_ext|show_message_input"
  key_links:
    - from: "src/app.rs"
      to: "git2::Repository"
      via: "stash_save_ext with StashSaveOptions and pathspec"
      pattern: "stash_save_ext|StashSaveOptions|pathspec"
    - from: "src/app.rs"
      to: "ratatui::widgets::Clear"
      via: "Text input popup overlay (reuses Phase 2 popup pattern)"
      pattern: "Clear|show_message_input"
---

<objective>
Implement the stash message prompt and selective stash creation for the Create Stash tab.

Purpose: Users can enter a descriptive message and create a stash from their selected files.
Output: Pressing 's' shows a message input popup; confirming creates a stash from selected files and refreshes the file list.
</objective>

<execution_context>
@/Users/sane/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sane/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-stash-creator/03-RESEARCH.md
@.planning/phases/03-stash-creator/03-01-SUMMARY.md
@src/app.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Text input state management and stash message popup</name>
  <files>src/app.rs</files>
  <action>
Add the text input state and popup rendering for the stash message:

1. **MessageInputState struct**: Create a struct for managing text input:
   - `input: String` - the current input text
   - `cursor_position: usize` - character-based cursor position (NOT byte position)

   Add methods:
   - `new() -> Self`: Initialize with empty string and cursor at 0.
   - `enter_char(&mut self, c: char)`: Insert character at cursor position. Use `byte_index()` helper to convert character position to byte index for `String::insert`. Then increment cursor_position.
   - `delete_char(&mut self)`: If cursor_position > 0, remove the character before the cursor. Reconstruct the string using `chars().take(pos-1).chain(chars().skip(pos))`. Decrement cursor_position.
   - `move_cursor_left(&mut self)`: `self.cursor_position = self.cursor_position.saturating_sub(1)`
   - `move_cursor_right(&mut self)`: Clamp to `self.input.chars().count()`
   - `byte_index(&self) -> usize`: Convert character position to byte index using `self.input.char_indices().map(|(i, _)| i).nth(self.cursor_position).unwrap_or(self.input.len())`
   - `value(&self) -> &str`: Return `&self.input`
   - `is_empty(&self) -> bool`: Return `self.input.is_empty()`

2. **App state additions**: Add fields to App:
   - `show_message_input: bool` - whether the message input popup is visible (init: false)
   - `message_input: MessageInputState` - the input state (init: new())

3. **Popup rendering**: Add a method `render_message_input_popup` that draws the text input popup:
   - Calculate a centered popup area: 60% width, 20% height. Use the same Layout + Flex::Center pattern as `render_confirm_popup`.
   - Render `Clear` widget first to erase background
   - Render a `Paragraph` with the input text inside a bordered block titled "Enter Stash Message (Enter: confirm, Esc: cancel)"
   - Set the cursor position using `frame.set_cursor_position(Position::new(popup_area.x + state.cursor_position as u16 + 1, popup_area.y + 1))`. The +1 on x accounts for the left border.
   - Call this render function in `render_tab_content` AFTER the main content, only when `self.show_message_input` is true.

4. **Popup key handling**: In `handle_key_event`, add a check for `self.show_message_input` BEFORE the confirm popup check and BEFORE normal key handling. When the message input popup is visible:
   - `KeyCode::Char(c)`: Call `self.message_input.enter_char(c)`. NOTE: This must NOT conflict with regular char handling. The early return ensures this.
   - `KeyCode::Backspace`: Call `self.message_input.delete_char()`
   - `KeyCode::Left`: Call `self.message_input.move_cursor_left()`
   - `KeyCode::Right`: Call `self.message_input.move_cursor_right()`
   - `KeyCode::Enter`: Call `self.create_stash()` (implemented in Task 2)
   - `KeyCode::Esc`: Cancel -- set `self.show_message_input = false`, reset `self.message_input = MessageInputState::new()`
   - Any other key: ignore
   - CRITICAL: Return early after handling to prevent background key processing (same pattern as confirm popup)

5. **Stash initiation (key: 's')**: In the normal key handling, when `selected_tab == Create`:
   - `KeyCode::Char('s')`: Check if any files are selected via `file_list_state.has_selection()`. If yes: set `show_message_input = true` and reset `message_input = MessageInputState::new()`. If no files selected: set `status_message = Some("No files selected. Use Space to select files first.".to_string())`.

6. **Help text during input**: When `show_message_input` is true, show: "Enter: Create Stash | Esc: Cancel | Type your stash message"

Add required imports: `use ratatui::layout::Position;` (if not already imported)
  </action>
  <verify>
Run `cargo build` and `cargo clippy` -- both must succeed with zero errors and zero warnings. Verify MessageInputState handles character insertion and deletion. Verify popup renders with cursor. Verify 's' key only opens popup when files are selected.
  </verify>
  <done>
Message input popup appears when 's' is pressed with selected files. User can type and edit the stash message. Esc cancels. Popup intercepts all keys while visible. Error message shown if no files selected.
  </done>
</task>

<task type="auto">
  <name>Task 2: Selective stash creation with pathspecs and file list refresh</name>
  <files>src/app.rs</files>
  <action>
Add the actual stash creation logic and file list refresh:

1. **create_stash method**: Add a method `create_stash(&mut self)` that:
   - Gets the selected file paths from `self.file_list_state` via `selected_files()`. If empty, set error status and return (safety check).
   - Gets the message from `self.message_input.value()`. If empty, use a default like "stash-mgr: manual stash" (but prefer requiring a message -- if empty, set status_message "Please enter a stash message" and return without closing popup so user can type).
   - Creates the stash using git2:
     ```rust
     let signature = self.repo.signature()?; // or handle error
     let mut opts = git2::StashSaveOptions::new(signature);
     opts.message(&message);
     for path in &selected_paths {
         opts.pathspec(path);
     }
     self.repo.stash_save_ext(Some(&mut opts))
     ```
   - On success:
     - Set `status_message = Some(format!("Stashed {} file(s): {}", count, message))`
     - Close popup: `self.show_message_input = false`
     - Reset input: `self.message_input = MessageInputState::new()`
     - Refresh file list: call `self.refresh_file_list()` to reload working directory state
     - Also refresh the stash list for the Manage tab: `self.stashes = Self::load_stashes(&mut self.repo)` and update stash selection/diff if needed
   - On error:
     - Set `status_message = Some(format!("Stash creation failed: {}", err))`
     - Close popup (user can retry)
     - Reset input

   IMPORTANT: Handle the `repo.signature()` error gracefully. If signature fails (no git user configured), show: "Stash failed: git user.name/email not configured". Use match or if-let, do NOT unwrap/panic.

2. **Stash list sync**: After creating a stash, the Manage tab's stash list should reflect the new stash. In `create_stash`, after successful creation:
   - Reload stashes: `self.stashes = Self::load_stashes(&mut self.repo)`
   - If stash list was empty before, select the first stash: `self.stash_list_state.select(Some(0))` and load its diff
   - If stash list was non-empty, keep current selection but note that indices may shift (new stash is at index 0). Safest: re-select index 0 since the new stash is always at the top.

3. **File list refresh behavior**: The `refresh_file_list()` method (from Plan 01) reloads files. After stash creation:
   - Files that were fully stashed will no longer appear (their status returns to clean)
   - Files that had mixed staged/unstaged changes may still appear with reduced changes
   - If all files become clean, the empty state "No modified files" should display
   - Selection should reset to index 0 (or None if empty) -- this is handled by `FileListState::new()`

4. **Edge case: empty pathspec guard**: Before calling `stash_save_ext`, verify that the selected_paths list is NOT empty. If empty, libgit2 will stash ALL files (dangerous). Return early with error message: "No files selected for stashing."

5. **Import additions**: Add `use git2::StashSaveOptions;` if not already imported. The `StashSaveOptions::new()` takes a `Signature` argument.

6. **Handle stash_save_ext not being available**: Check if `stash_save_ext` is available in git2 0.20. If not available, fall back to alternative approach:
   - Alternative: Use `repo.stash_save(&signature, &message, Some(flags))` for all files, which won't support selective stashing.
   - If `stash_save_ext` IS available (it should be in git2 0.20+), use it with pathspecs.
   - If compilation fails due to API mismatch, adapt to the available API. The research indicates `stash_save_ext` with `StashSaveOptions::pathspec()` is available.
  </action>
  <verify>
Run `cargo build` and `cargo clippy` -- both must succeed with zero errors and zero warnings. Verify stash_save_ext is called with pathspecs from selected files. Verify file list refreshes after stash creation. Verify stash list on Manage tab updates. Verify empty pathspec guard prevents full working directory stash.
  </verify>
  <done>
User can enter a message and create a stash from selected files. Stash is created with only the selected files (pathspec filtering). File list refreshes showing updated working directory. Stash list on Manage tab updates to include the new stash. Empty message and empty selection are guarded against.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds with zero errors
2. `cargo clippy` succeeds with zero warnings
3. Pressing 's' with selected files shows message input popup
4. Pressing 's' with no files selected shows error message
5. User can type a stash message and see it in the popup
6. Enter creates the stash; Esc cancels
7. Created stash contains only the selected files (pathspec filtering)
8. File list refreshes after stash creation (stashed files disappear)
9. Stash list on Manage tab includes the newly created stash
10. Empty message is rejected with feedback
11. All keys are intercepted during message input (no background actions)
</verification>

<success_criteria>
- CREA-04: User is prompted for stash message via text input popup
- CREA-05: Stash is created from selected files only (pathspec-based selective stashing)
- CREA-06: File list refreshes after stash creation to show updated state
- Error cases handled: no selection, empty message, git errors, missing signature
- Manage tab stash list stays in sync after creation
</success_criteria>

<output>
After completion, create `.planning/phases/03-stash-creator/03-02-SUMMARY.md`
</output>
